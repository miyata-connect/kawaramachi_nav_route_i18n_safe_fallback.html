<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Cloudflare Workers ナビ</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<style>
:root{
  --bg:#0f1a25; --panel:#132235; --panel2:#0f1e30;
  --text:#eaf2ff; --muted:#9db0c6;
  --ok:#2ecc71; --primary:#4aa3ff; --danger:#ff6b6b;
}
html,body{height:100%;margin:0;background:var(--bg);color:var(--text);
  font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP","Helvetica Neue",Arial,"メイリオ",Meiryo,sans-serif}
.wrap{max-width:1100px;margin:0 auto;padding:12px}
.card{background:var(--panel);border-radius:14px;padding:12px;box-shadow:0 6px 18px rgba(0,0,0,.28)}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
.grow{flex:1 1 200px}
input,button,select{border-radius:12px;border:1px solid rgba(255,255,255,.08);
  background:var(--panel2);color:var(--text);padding:12px 14px;font-size:16px;outline:none}
input::placeholder{color:#8aa2bc}
button.primary{background:var(--primary);border:none;font-weight:700}
button.ghost{background:transparent;border:1px solid rgba(255,255,255,.15)}
button.ok{background:var(--ok);border:none;font-weight:700}
button.danger{background:var(--danger);border:none;font-weight:700}
.hint{color:var(--muted);font-size:14px}

/* ====== Map & Controls ====== */
.mapwrap{position:relative}
#map{height:64vh;border-radius:16px;overflow:hidden}

/* コンパス */
.compass{position:absolute;left:16px;top:16px;z-index:450;width:82px;height:82px;
  border-radius:50%;box-shadow:0 6px 16px rgba(0,0,0,.35);pointer-events:none}
.compass svg{display:block;width:100%;height:100%}
.compass text{font-size:10px;fill:#f6d365;letter-spacing:.1em}
#needle{transform-box:fill-box;transform-origin:37px 37px;transition:transform .3s ease-out}
#needle polygon{fill:#ff4e4e;filter:drop-shadow(0 4px 8px rgba(0,0,0,.35))}

/* Leaflet 調整 */
.leaflet-control-zoom{left:10px!important;right:auto!important;bottom:14px!important;top:auto!important}
.leaflet-control-attribution{
    left:8px!important;right:auto!important;bottom:10px!important;
    max-width: calc(100vw - 90px) !important;
    white-space: normal !important; /* ★修正：強制折り返し */
    overflow-wrap: break-word !important;
}

/* 右下ボタン列 */
.fab-col{position:absolute;right:12px;bottom:88px;z-index:460;display:flex;flex-direction:column;gap:10px}
.fab-col button{min-width:126px;padding:10px 12px;font-weight:700;box-shadow:0 10px 20px rgba(0,0,0,.35)}
.fab-col .danger{margin-bottom:4px}

/* 検索結果 */
.results{margin-top:10px}
.result{background:#0b1624;border:1px solid rgba(255,255,255,.08);padding:10px 12px;border-radius:12px;margin-bottom:8px;cursor:pointer}
.result small{color:#a9bed5}
.badge{display:inline-block;background:rgba(255,255,255,.08);padding:3px 8px;border-radius:999px;margin-left:6px}
.results .body{max-height:44vh;overflow:auto;margin-top:8px}

/* 地名登録モーダル */
.modal{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;z-index:1000}
.modal .box{background:var(--panel);border-radius:16px;max-width:520px;width:92vw;padding:16px;box-shadow:0 18px 40px rgba(0,0,0,.5)}
.modal .title{font-weight:800;margin-bottom:8px}
.modal .row{margin-top:8px}
.modal .actions{display:flex;gap:10px;justify-content:flex-end;margin-top:12px}

@media (max-width:640px){
  #map{height:68vh}
  .fab-col button{min-width:118px;padding:9px 11px;font-size:15px}
}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="row">
      <input id="q" class="grow" placeholder="店舗名・住所・電話番号で検索" autocomplete="off">
      <button id="mic" class="ghost">🎤 音声</button>
      <button id="search" class="primary">検索</button>
    </div>
    <div class="row" style="margin-top:8px">
      <button id="clearHistory" class="ghost">履歴をクリア</button>
      <span class="hint">検索後は近場5件を表示 → 候補タップで目的地に設定 → ルート取得 → 案内開始</span>
    </div>
  </div>
  <div class="card" style="margin-top:12px">
    <div class="row">
      <div class="grow">
        <div class="hint">開始地点（経度・緯度）</div>
        <div class="row">
          <input id="startLon" class="grow" placeholder="経度" inputmode="decimal">
          <input id="startLat" class="grow" placeholder="緯度" inputmode="decimal">
        </div>
      </div>
      <div class="grow">
        <div class="hint">目的地（経度・緯度）</div>
        <div class="row">
          <input id="destLon" class="grow" placeholder="経度" inputmode="decimal">
          <input id="destLat" class="grow" placeholder="緯度" inputmode="decimal">
        </div>
      </div>
    </div>
    <div class="row" style="margin-top:10px">
      <button id="modeWalk"  class="primary">徒歩</button>
      <button id="modeWheel" class="ghost">車椅子</button>
      <div class="grow"></div>
      <button id="getRoute" class="primary">ルート取得</button>
      <button id="clear" class="ghost">クリア</button>
    </div>
    <div class="row" style="margin-top:12px">
      <div class="grow">
        <div class="hint">記憶地点（この端末に保存）</div>
        <div class="row">
          <select id="savedList" class="grow"></select>
          <button id="openSaveModal" class="ok">現在地を保存</button>
          <button id="setFromSaved" class="primary">目的地に設定</button>
          <button id="delSaved" class="danger">削除</button>
        </div>
      </div>
    </div>
    <div id="msg" class="hint" style="margin-top:6px;">準備完了。目的地を設定してください</div>
  </div>
  <div class="card mapwrap" style="margin-top:12px">
    <div id="map"></div>
    <div class="compass" aria-hidden="true">
      <svg viewBox="0 0 74 74">
        <defs>
          <radialGradient id="g1" cx="50%" cy="50%" r="60%">
            <stop offset="0%"  stop-color="#0b1624"/>
            <stop offset="60%" stop-color="#0a1320"/>
            <stop offset="100%" stop-color="#07121e"/>
          </radialGradient>
        </defs>
        <circle cx="37" cy="37" r="36" fill="url(#g1)" stroke="rgba(255,255,255,.15)"/>
        <text x="37" y="12" text-anchor="middle">N</text>
        <g id="needle">
          <polygon points="37,11 31.5,37 42.5,37"/>
        </g>
        <text x="37" y="66" text-anchor="middle" fill="#b8cce2">進行方向</text>
      </svg>
    </div>
    <div class="fab-col">
      <button id="navStart" class="ok">案内開始</button>
      <button id="gotoStart" class="primary">現在地</button>
      <button id="gotoDest"  class="primary">目的地</button>
      <button id="reroute"   class="danger">リルート</button>
    </div>
  </div>
  <div class="card results" id="results" style="display:none">
    <div class="row" style="justify-content:space-between;align-items:center">
      <div><span class="badge">検索結果（近隣 上位5件）</span></div>
      <button id="closeResults" class="ghost">閉じる</button>
    </div>
    <div id="resultList" class="body"></div>
  </div>
</div>
<div class="modal" id="saveModal">
  <div class="box">
    <div class="title">現在地を保存</div>
    <div class="row">
      <input id="saveName" class="grow" placeholder="地点名を入力（例：自宅・公園）">
    </div>
    <div class="row">
      <input id="saveLon" class="grow" placeholder="経度" inputmode="decimal">
      <input id="saveLat" class="grow" placeholder="緯度" inputmode="decimal">
    </div>
    <div class="actions">
      <button id="cancelSave" class="ghost">キャンセル</button>
      <button id="doSave" class="ok">保存</button>
    </div>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
// ===== ★★★ 全体エラーハンドリング ★★★ =====
window.addEventListener('error', event => {
  setMessage(`スクリプトエラー: ${event.message}`, 'danger');
});
window.addEventListener('unhandledrejection', event => {
  setMessage(`非同期処理エラー: ${event.reason}`, 'danger');
});

/* ===== 設定 ===== */
const WORKER_ORIGIN='https://ors-proxy.miyata-connect-jp.workers.dev/proxy';
let profile='foot-walking';

/* ===== DOM要素 ===== */
const els = {};
document.addEventListener('DOMContentLoaded', () => {
    const ids = [
        'q', 'mic', 'search', 'clearHistory', 'results', 'resultList', 'closeResults',
        'startLat', 'startLon', 'destLat', 'destLon', 'modeWalk', 'modeWheel',
        'getRoute', 'clear', 'msg', 'navStart', 'gotoStart', 'gotoDest', 'reroute',
        'needle', 'savedList', 'openSaveModal', 'setFromSaved', 'delSaved',
        'saveModal', 'saveName', 'saveLon', 'saveLat', 'cancelSave', 'doSave'
    ];
    ids.forEach(id => els[id] = document.getElementById(id));
    init(); // DOMの準備ができてから初期化
});

/* ===== グローバル変数 ===== */
let map, routeGroup, currentMarker, destMarker, routeLine, lastRoute, watchId;
let navActive = false, prevPos = null;

/* ===== 汎用関数 ===== */
function setMessage(text, type = 'hint') {
    if (els.msg) {
        els.msg.textContent = text;
        els.msg.style.color = type === 'danger' ? 'var(--danger)' : 'var(--muted)';
    }
    if (type === 'danger') console.error(text);
}
function escapeHtml(s){return String(s).replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]))}

/* ===== 地図関連 ===== */
function initMap() {
    map = L.map('map', { zoomControl: false }).setView([34.342, 134.046], 16);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 20 }).addTo(map);
    L.control.zoom({ position: 'bottomleft' }).addTo(map);
    routeGroup = L.layerGroup().addTo(map);
}
function setStart(lon, lat) { els.startLon.value = lon ?? ''; els.startLat.value = lat ?? ''; }
function setDest(lon, lat) {
    els.destLon.value = lon ?? ''; els.destLat.value = lat ?? '';
    if (Number.isFinite(lat) && Number.isFinite(lon)) {
        if (!destMarker) destMarker = L.marker([lat, lon], { title: '目的地' }).addTo(map);
        else destMarker.setLatLng([lat, lon]);
    }
}
function updateCurrent(latlng) {
    if (!currentMarker) currentMarker = L.marker(latlng, { title: '現在地' }).addTo(map);
    else currentMarker.setLatLng(latlng);
}

/* ===== コンパス ===== */
const compass = { angle: 0, target: 0, raf: null };
function updateCompassRotation() {
    const d = shortDiff(compass.angle, compass.target);
    if (Math.abs(d) < 0.5) {
        compass.angle = compass.target; cancelAnimationFrame(compass.raf); compass.raf = null;
    } else {
        compass.angle = norm360(compass.angle + d * 0.1);
        compass.raf = requestAnimationFrame(updateCompassRotation);
    }
    if (els.needle) els.needle.style.transform = `rotate(${compass.angle}deg)`;
}
function setCompassTarget(deg) {
    if (!Number.isFinite(deg)) return;
    compass.target = norm360(deg);
    if (!compass.raf) updateCompassRotation();
}
function norm360(x) { x %= 360; if (x < 0) x += 360; return x; }
function shortDiff(a, b) { let d = norm360(b) - norm360(a); if (d > 180) d -= 360; if (d < -180) d += 360; return d; }

/* ===== 現在地 ===== */
function initGeolocation() {
    setMessage('現在地を取得中...');
    if (!navigator.geolocation) return setMessage('この端末は位置情報に未対応です', 'danger');
    
    navigator.geolocation.getCurrentPosition(pos => {
        const { latitude, longitude, heading } = pos.coords;
        setStart(longitude, latitude);
        updateCurrent([latitude, longitude]);
        if (Number.isFinite(heading)) setCompassTarget(heading);
        map.setView([latitude, longitude], 17);
        prevPos = L.latLng(latitude, longitude);
        setMessage('現在地を取得しました。');
    }, err => {
        setMessage(`現在地エラー: ${err.message}`, 'danger');
    }, { enableHighAccuracy: true, maximumAge: 1000, timeout: 10000 });

    if (watchId) navigator.geolocation.clearWatch(watchId);
    watchId = navigator.geolocation.watchPosition(pos => {
        const { latitude, longitude, heading } = pos.coords;
        const cur = L.latLng(latitude, longitude);
        updateCurrent([latitude, longitude]);
        setStart(longitude, latitude);
        
        if (Number.isFinite(heading)) setCompassTarget(heading);
        else if (prevPos && cur.distanceTo(prevPos) > 3) {
            const bearing = bearingBetween(prevPos, cur);
            setCompassTarget(bearing);
            prevPos = cur;
        }
    }, () => {}, { enableHighAccuracy: true, maximumAge: 3000, timeout: 10000 });
}
function bearingBetween(a, b) {
    const toRad = t => t * Math.PI / 180, toDeg = t => t * 180 / Math.PI;
    const φ1 = toRad(a.lat), φ2 = toRad(b.lat), λ1 = toRad(a.lng), λ2 = toRad(b.lng);
    const y = Math.sin(λ2 - λ1) * Math.cos(φ2);
    const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(λ2 - λ1);
    return norm360(toDeg(Math.atan2(y, x)));
}

/* ===== ルート ===== */
async function fetchAndDrawRoute() {
    const slon = Number(els.startLon.value), slat = Number(els.startLat.value);
    const dlon = Number(els.destLon.value), dlat = Number(els.destLat.value);
    if (![slon, slat, dlon, dlat].every(Number.isFinite)) {
        setMessage('座標が不足しています', 'danger'); return null;
    }
    setMessage('ルート取得中...');
    const body = { coordinates: [[slon, slat], [dlon, dlat]], instructions: true, language: 'ja', profile: profile, geometry: true, geometry_format: 'geojson' };
    try {
        const res = await fetch(WORKER_ORIGIN, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
        if (!res.ok) throw new Error(`サーバーエラー: ${res.status}`);
        const j = await res.json();
        const route = j?.routes?.[0];
        if (!route?.geometry?.coordinates?.length) throw new Error('ルート形状が受信できませんでした');
        
        drawRoute(route);
        setMessage('ルート取得完了');
        map.fitBounds(routeLine.getBounds(), { padding: [30, 30] });
        return route;
    } catch (e) {
        setMessage(`ルート取得失敗: ${e.message}`, 'danger');
        return null;
    }
}
function drawRoute(route) {
    routeGroup.clearLayers();
    lastRoute = route || null;
    const coords = route?.geometry?.coordinates || [];
    const latlngs = coords.map(([lon, lat]) => [lat, lon]);
    routeLine = latlngs.length ? L.polyline(latlngs, { color: '#39b6ff', weight: 6, opacity: .9 }).addTo(routeGroup) : null;
}

/* ===== 案内 ===== */
function speakJa(txt) { try { const u = new SpeechSynthesisUtterance(txt); u.lang = 'ja-JP'; window.speechSynthesis.cancel(); window.speechSynthesis.speak(u); } catch {} }
function startNavigation() {
    if (!routeLine) return setMessage('先にルートを取得してください', 'danger');
    navActive = true;
    map.fitBounds(routeLine.getBounds(), { padding: [30, 30] });
    const step = lastRoute?.segments?.[0]?.steps?.[0]?.instruction;
    const initialAnnounce = '案内を開始します。' + (step || '');
    setMessage(initialAnnounce);
    speakJa(initialAnnounce);
}

/* ===== 検索 ===== */
async function performSearch() {
    const raw = els.q.value.trim(); if (!raw) return setMessage('検索ワードを入力してください', 'danger');
    let lat = Number(els.startLat.value), lon = Number(els.startLon.value);
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) { const c = map.getCenter(); lat = c.lat; lon = c.lng; }

    setMessage('検索中...');
    const items = await mergedSearch(raw, lat, lon);
    showResults(items);

    if (items.length) {
        const best = items[0];
        setDest(best.lon, best.lat);
        map.flyTo([best.lat, best.lon], 17);
        const route = await fetchAndDrawRoute();
        if (route) {
            startNavigation();
            setMessage('最上位候補で案内を開始しました');
        }
    } else {
        setMessage('近隣に候補が見つかりません');
    }
    saveHistory(raw);
}
async function mergedSearch(raw, lat, lon) {
    const queries = buildQueries(raw);
    const photonPromise = photonQuery({q: queries[0], lat, lon, limit:10});
    const nominatimPromise = nominatimQuery({q: queries[0], box: degBox(lat, lon, 20000), limit:10});
    
    const results = await Promise.all([photonPromise, nominatimPromise]);
    const pool = [...results[0], ...results[1]];

    const seen = new Set(), out = [];
    for (const it of pool.sort((a, b) => a.dist - b.dist)) {
        const key = it.name + '@' + it.lat.toFixed(5) + ',' + it.lon.toFixed(5);
        if (!seen.has(key)) { seen.add(key); out.push(it); }
        if (out.length >= 5) break;
    }
    return out;
}
function buildQueries(raw) { return [raw]; } // シンプル化
async function photonQuery(params) { /* ... 内容は変更なし ... */ return []; }
async function nominatimQuery(params) { /* ... 内容は変更なし ... */ return []; }
// 元の長い関数定義をここにペースト
async function photonQuery({q,lat,lon,limit=30}){ const url=new URL('https://photon.komoot.io/api/'); url.searchParams.set('q',q); url.searchParams.set('lang','ja'); url.searchParams.set('lat',lat); url.searchParams.set('lon',lon); url.searchParams.set('limit',String(limit)); try{ const r=await fetch(url.toString()); if(!r.ok) return []; const js=await r.json(); const here=L.latLng(lat,lon); return (js.features||[]).map(f=>{ const p=f.properties,c=f.geometry.coordinates; const ll=L.latLng(c[1],c[0]); return {name:p.name||p.street||p.city||'名称不明',addr:[p.city,p.street,p.housenumber].filter(Boolean).join(' '), lon:c[0],lat:c[1],dist:here.distanceTo(ll),src:'photon'}; }); }catch{return []} }
async function nominatimQuery({q,box,limit=30}){ const url=new URL('https://nominatim.openstreetmap.org/search'); url.searchParams.set('q',q); url.searchParams.set('format','jsonv2'); url.searchParams.set('accept-language','ja'); url.searchParams.set('bounded','1'); url.searchParams.set('viewbox',`${box.w},${box.n},${box.e},${box.s}`); url.searchParams.set('limit',String(limit)); try{ const r=await fetch(url.toString(),{headers:{'User-Agent':'cf-workers-nav-demo'}}); if(!r.ok) return []; const js=await r.json(); const here=L.latLng((box.n+box.s)/2,(box.e+box.w)/2); return js.map(o=>{ const ll=L.latLng(Number(o.lat),Number(o.lon)); return {name:o.display_name.split(',')[0]||'名称不明',addr:o.display_name,lon:Number(o.lon),lat:Number(o.lat), dist:here.distanceTo(ll),src:'nominatim'}; }); }catch{return []} }
function degBox(lat,lon,meters){ const dLat=meters/111320; const dLon=meters/(40075000*Math.cos(lat*Math.PI/180)/360); return {n:lat+dLat,s:lat-dLat,e:lon+dLon,w:lon-dLon}; }

function showResults(items) {
    els.results.style.display = 'block';
    els.resultList.innerHTML = '';
    if (!items.length) return els.resultList.innerHTML = '<div class="hint">該当なし</div>';
    items.forEach((it, i) => {
        const div = document.createElement('div'); div.className = 'result';
        div.innerHTML = `<div><strong>${i + 1}. ${escapeHtml(it.name)}</strong></div>
            <small>${(it.dist / 1000).toFixed(2)} km　${escapeHtml(it.addr || '')}
            <span class="badge">${it.lat.toFixed(5)}, ${it.lon.toFixed(5)}</span></small>`;
        div.addEventListener('click', async () => {
            setDest(it.lon, it.lat);
            map.flyTo([it.lat, it.lon], 17);
            const route = await fetchAndDrawRoute();
            if (route) startNavigation();
        });
        els.resultList.appendChild(div);
    });
}
/* ===== 履歴・地点保存・音声認識・イベントリスナー ===== */
// ... (これらのセクションは比較的安定しているので、元のコードを流用)
// 履歴
const HISTORY_KEY='mc_search_history';
const loadHistory=()=>{try{return JSON.parse(localStorage.getItem(HISTORY_KEY)||'[]')}catch{return []}};
function saveHistory(q){ if(!q) return; const arr=loadHistory().filter(x=>x!==q); arr.unshift(q); localStorage.setItem(HISTORY_KEY,JSON.stringify(arr.slice(0,20))); }
function clearHistory(){ localStorage.removeItem(HISTORY_KEY); els.q.value=''; els.results.style.display='none'; els.resultList.innerHTML=''; setMessage('履歴をクリアしました'); }
// 地点保存
const SAVE_KEY='mc_saved_places';
function loadSaves(){ try{return JSON.parse(localStorage.getItem(SAVE_KEY)||'[]')}catch{return []} }
function saveSaves(arr){ localStorage.setItem(SAVE_KEY,JSON.stringify(arr)); refreshSaveList(); }
function refreshSaveList(){ const arr=loadSaves(); els.savedList.innerHTML=''; const opt=document.createElement('option'); opt.value=''; opt.textContent='（未選択）'; els.savedList.appendChild(opt); arr.forEach((p,i)=>{ const o=document.createElement('option'); o.value=String(i); o.textContent=`${p.name} ー ${p.lat.toFixed(5)}, ${p.lon.toFixed(5)}`; els.savedList.appendChild(o); }); }
function openSave(){ let lat=Number(els.startLat.value), lon=Number(els.startLon.value); if((!Number.isFinite(lat)||!Number.isFinite(lon)) && currentMarker){ const c=currentMarker.getLatLng(); lat=c.lat; lon=c.lng; } els.saveName.value=''; els.saveLon.value=Number.isFinite(lon)?lon:''; els.saveLat.value=Number.isFinite(lat)?lat:''; els.saveModal.style.display='flex'; }
function doSave(){ const name=els.saveName.value.trim()||'地点'; const lon=Number(els.saveLon.value), lat=Number(els.saveLat.value); if(![lon,lat].every(Number.isFinite)){ return setMessage('保存に必要な座標が不正です', 'danger'); } const arr=loadSaves(); arr.unshift({name,lat,lon}); saveSaves(arr.slice(0,50)); els.saveModal.style.display='none'; setMessage('現在地を保存しました'); }
async function setFromSaved(){ const val=els.savedList.value; if(val===''){ return setMessage('地点を選んでください', 'danger'); } const idx=Number(val), arr=loadSaves(); if(arr[idx]==null){ return setMessage('地点が見つかりません', 'danger'); } setDest(arr[idx].lon,arr[idx].lat); map.flyTo([arr[idx].lat,arr[idx].lon],17); const route = await fetchAndDrawRoute(); if(route) startNavigation(); }
function delSaved(){ const val=els.savedList.value; if(val===''){ return setMessage('削除する地点を選んでください', 'danger'); } const idx=Number(val), arr=loadSaves(); if(arr[idx]==null){ return setMessage('地点が見つかりません', 'danger'); } arr.splice(idx,1); saveSaves(arr); setMessage('削除しました'); }
// 音声
function startVoice(){ const SR=window.SpeechRecognition||window.webkitSpeechRecognition; if(!SR){ return setMessage('音声入力に未対応のブラウザです', 'danger'); } const rec=new SR(); rec.lang='ja-JP'; rec.interimResults=false; rec.maxAlternatives=1; rec.onresult=(ev)=>{ els.q.value=ev.results[0][0].transcript||''; performSearch(); }; rec.onerror=()=>{ setMessage('音声入力に失敗しました', 'danger'); }; rec.start(); }
// イベントリスナー
function setupEventListeners() {
    async function handleGetRouteAndNavigate() { const route = await fetchAndDrawRoute(); if (route) startNavigation(); }
    els.search.addEventListener('click', performSearch);
    els.q.addEventListener('keypress', e => { if (e.key === 'Enter') performSearch(); });
    els.mic.addEventListener('click', startVoice);
    els.clearHistory.addEventListener('click', clearHistory);
    els.closeResults.addEventListener('click', () => els.results.style.display = 'none');
    els.modeWalk.addEventListener('click', () => { profile = 'foot-walking'; els.modeWalk.className = 'primary'; els.modeWheel.className = 'ghost'; });
    els.modeWheel.addEventListener('click', () => { profile = 'wheelchair'; els.modeWalk.className = 'ghost'; els.modeWheel.className = 'primary'; });
    els.getRoute.addEventListener('click', handleGetRouteAndNavigate);
    els.clear.addEventListener('click', () => { routeGroup.clearLayers(); routeLine = null; lastRoute = null; navActive = false; if(destMarker){map.removeLayer(destMarker);destMarker=null;} els.destLat.value=els.destLon.value=''; setMessage('クリアしました。'); });
    els.navStart.addEventListener('click', startNavigation);
    els.gotoStart.addEventListener('click', () => { if (currentMarker) map.flyTo(currentMarker.getLatLng(), 18); });
    els.gotoDest.addEventListener('click', () => { if (destMarker) map.flyTo(destMarker.getLatLng(), 18); });
    els.reroute.addEventListener('click', handleGetRouteAndNavigate);
    els.openSaveModal.addEventListener('click', openSave);
    els.setFromSaved.addEventListener('click', setFromSaved);
    els.delSaved.addEventListener('click', delSaved);
    els.cancelSave.addEventListener('click', () => els.saveModal.style.display = 'none');
    els.doSave.addEventListener('click', doSave);
    map.on('contextmenu', e => { setDest(e.latlng.lng, e.latlng.lat); setMessage('目的地を設定しました'); });
}

/* ===== 初期化 ===== */
function init() {
    try {
        setMessage('アプリケーションを初期化中...');
        initMap();
        setupEventListeners();
        refreshSaveList();
        initGeolocation();
        if (els.needle) els.needle.style.transform = 'rotate(0deg)';
        setMessage('準備完了。目的地を設定してください。');
    } catch (e) {
        setMessage(`初期化エラー: ${e.message}`, 'danger');
        document.body.innerHTML = `<div style="padding:20px; color:red;">致命的なエラーが発生しました: ${e.message}</div>`;
    }
}
</script>
</body>
</html>
