<script>
/* ====== 機能フラグ ====== */
const FLAGS = {
  VOICE:true,
  SAVE_PLACES:true,
  REROUTE:true
};

/* ====== 状態機械（最小骨格） ======
   どの機能も必ず dispatch() に投げる */
const State = {
  value: 'IDLE', // IDLE -> ROUTE_READY -> NAVIGATING -> REROUTING
  ctx: { haveRoute:false, lastMoveAt:0 }
};
const handlers = {
  IDLE: {
    ROUTE_LOADED(){ State.value='ROUTE_READY'; State.ctx.haveRoute=true; uiStatus('ルート準備完了'); },
    START_GUIDE(){ warn('まずルートを取得してください'); }
  },
  ROUTE_READY: {
    START_GUIDE(){ State.value='NAVIGATING'; uiStatus('案内を開始'); say('案内を開始します'); },
    CLEAR(){ State.value='IDLE'; State.ctx.haveRoute=false; uiStatus('クリアしました'); }
  },
  NAVIGATING: {
    OFF_ROUTE(){ if(!FLAGS.REROUTE) return; State.value='REROUTING'; uiStatus('リルート中…'); sayOnce('通り過ぎました。リルートします。'); },
    ARRIVED(){ State.value='IDLE'; State.ctx.haveRoute=false; uiStatus('到着しました'); say('到着しました'); },
    CLEAR(){ State.value='IDLE'; State.ctx.haveRoute=false; uiStatus('クリアしました'); }
  },
  REROUTING: {
    ROUTE_LOADED(){ State.value='NAVIGATING'; uiStatus('リルート完了'); say('リルートしました'); },
    CLEAR(){ State.value='IDLE'; State.ctx.haveRoute=false; uiStatus('クリアしました'); }
  }
};
function dispatch(event){
  const h = handlers[State.value]?.[event.type];
  if(h){ try{ h(event.data); }catch(e){ console.error(e); toast('内部エラー'); } }
}

/* ====== スモークテスト（起動時に1回） ====== */
(function smoke(){
  const problems=[];
  const must = (sel, name) => { if(!document.querySelector(sel)) problems.push(`${name} が見つからない (${sel})`); };
  // 必須UI
  must('#locBtn','現在地ボタン');
  must('#routeBtn','ルート取得ボタン');
  must('#startGuideBtn','案内開始ボタン');
  must('#rerouteBtn','リルートボタン');
  must('#q','検索入力欄');
  // 主要関数（存在だけ確認。あなたの既存関数名に合わせて）
  if(typeof window.getRoute!=='function') problems.push('getRoute() が未定義');
  if(typeof window.startGuidance!=='function') problems.push('startGuidance() が未定義');
  // 見つかったら上部に赤帯で通知
  if(problems.length){
    const bar = document.createElement('div');
    bar.style.cssText='position:fixed;top:0;left:0;right:0;z-index:9999;background:#ff4d4f;color:#fff;padding:8px 12px;font-weight:700';
    bar.textContent='初期チェック失敗：'+problems.join(' / ');
    document.body.appendChild(bar);
    console.warn('SMOKE FAIL:', problems);
  }else{
    console.log('SMOKE OK');
  }
})();

/* ====== 連打・連発対策（案内音声のデバウンス） ====== */
let _lastSay=0, _lastText='';
function say(t){
  try{
    const now=Date.now();
    if(now-_lastSay<1200) return;          // 1.2秒以内の多重発声を抑制
    if(t===_lastText) return;              // 同一文の連続発話を抑制
    const u=new SpeechSynthesisUtterance(t); u.lang='ja-JP';
    speechSynthesis.cancel(); speechSynthesis.speak(u);
    _lastSay=now; _lastText=t;
  }catch{}
}
function sayOnce(t){ if(t!==_lastText) say(t); }

/* ====== ユーティリティ ====== */
function uiStatus(t){ const el=document.getElementById('status'); if(el) el.textContent=t; }
function toast(t){
  const d=document.createElement('div');
  d.style.cssText='position:fixed;bottom:14px;left:50%;transform:translateX(-50%);background:#1f3a77;color:#fff;padding:8px 12px;border-radius:10px;z-index:9999';
  d.textContent=t; document.body.appendChild(d); setTimeout(()=>d.remove(),1800);
}
function warn(t){ toast(t); say(t); }

/* ====== あなたの既存コードに “フック” を追加して使う ======
   1) ルート取得成功時： dispatch({type:'ROUTE_LOADED'})
   2) 案内開始ボタン押下： dispatch({type:'START_GUIDE'})
   3) 到着検知時： dispatch({type:'ARRIVED'})
   4) 5m以上外れた判定確定： dispatch({type:'OFF_ROUTE'})
   5) クリア時： dispatch({type:'CLEAR'})
   ※ 既存処理はそのままでOK。イベントだけ投げる。 */
</script>