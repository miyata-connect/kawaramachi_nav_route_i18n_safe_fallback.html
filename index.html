<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>WalkNav</title>
  <style>
    :root{
      --bg:#0a1321;
      --text:#eaf2ff;
      --muted:#a7b8ce;
      --accent:#5fb1ff;
      --glass: rgba(20,28,44,.78);
      --stroke: rgba(255,255,255,.12);
      --ok:#25d07a;
      --danger:#ff6565;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    *{box-sizing:border-box}
    .app{position:relative;height:100dvh;overflow:hidden}
    #map{position:absolute;inset:0}

    .overlay{
      position:absolute;left:12px;right:12px;top:12px;
      padding:16px 18px;border-radius:16px;background:var(--glass);
      border:1px solid var(--stroke);backdrop-filter:blur(6px)
    }
    .row{display:flex;gap:10px;align-items:center;justify-content:space-between}
    .pill{
      position:fixed;right:12px;display:flex;flex-direction:column;gap:14px;
      bottom:18px;z-index:3
    }
    .btn{
      width:96px;height:96px;border-radius:24px;background:rgba(255,255,255,.08);
      display:flex;align-items:center;justify-content:center;
      border:1px solid var(--stroke);color:var(--text);text-decoration:none;
      box-shadow:0 10px 30px rgba(0,0,0,.25);cursor:pointer
    }
    .toast{
      position:fixed;left:16px;right:16px;bottom:16px;padding:14px 16px;
      border-radius:12px;background:#ff6b6b;color:white;border:0;display:none;z-index:5
    }
    .hidden{display:none !important}
  </style>
</head>
<body>
  <div class="app">
    <div id="map" aria-label="map"></div>

    <div id="panel" class="overlay">
      <div class="row">
        <strong id="panel-title">Set your destination</strong>
        <span id="coord" style="font-variant-numeric:tabular-nums;color:var(--muted)">Lat: -- / Lng: --</span>
      </div>
    </div>

    <div class="pill">
      <button id="btn-current" class="btn" title="Current">Current</button>
      <button id="btn-search" class="btn" title="Search">Search</button>
      <button id="btn-stop" class="btn" title="Stop">Stop</button>
      <button id="btn-dest" class="btn" title="Destination">Dest</button>
      <button id="btn-reroute" class="btn" title="Reroute">Reroute</button>
      <button id="btn-ops" class="btn" title="Ops">Ops</button>
    </div>

    <div id="toast" class="toast" role="status" aria-live="polite"></div>
  </div>

  <!-- Google Maps JS API (use latest browser key) -->
  <script async src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBzojEE2142O8dWPd7gmcAj-FyWumYyFy4&v=weekly&language=en&region=JP&loading=async"></script>

  <script type="module">
    // ---------- Toast ----------
    const toast = (msg, ok=false) => {
      const el = document.getElementById('toast');
      el.style.background = ok ? "var(--ok)" : "var(--danger)";
      el.textContent = msg;
      el.style.display = "block";
      clearTimeout(el._t);
      el._t = setTimeout(()=>{ el.style.display="none"; }, 3000);
    };

    // ---------- Ensure Google Maps loaded ----------
    async function waitForGoogleMaps(timeout = 15000) {
      const t0 = performance.now();
      while (performance.now() - t0 < timeout) {
        if (globalThis.google?.maps?.importLibrary) return;
        await new Promise(r => setTimeout(r, 50));
      }
      throw new Error("Google Maps failed to load within timeout");
    }

    // ---------- Cloudflare Proxy ----------
    const PROXY_BASE = "https://ors-proxy.miyata-connect-jp.workers.dev";

    async function cfPlacesSearchText(payload) {
      const r = await fetch(`${PROXY_BASE}/places:searchText`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });
      if (!r.ok) throw new Error(`places: ${r.status}`);
      return r.json();
    }

    async function cfDirections(params) {
      const q = new URLSearchParams(params);
      const r = await fetch(`${PROXY_BASE}/directions?${q}`);
      if (!r.ok) throw new Error(`directions: ${r.status}`);
      return r.json();
    }

    // ---------- App ----------
    let map, currentMarker, destMarker, routePolyline;
    let currentPos = { lat: 35.681236, lng: 139.767125 }; // Tokyo default
    let destination = null;

    function setCoordLabel(pos) {
      const c = document.getElementById("coord");
      c.textContent = `Lat: ${pos.lat.toFixed(6)} / Lng: ${pos.lng.toFixed(6)}`;
    }

    async function getLocation() {
      return new Promise((resolve,reject)=>{
        if (!navigator.geolocation) return reject(new Error("Geolocation unsupported"));
        navigator.geolocation.getCurrentPosition(
          p => resolve({ lat: p.coords.latitude, lng: p.coords.longitude }),
          e => reject(new Error(e.message || "Location error")),
          { enableHighAccuracy:true, timeout:10000, maximumAge:0 }
        );
      });
    }

    function clearRoute() {
      if (routePolyline) {
        routePolyline.setMap(null);
        routePolyline = null;
      }
    }

    try {
      await waitForGoogleMaps();
      const { Map } = await google.maps.importLibrary("maps");
      const { AdvancedMarkerElement } = await google.maps.importLibrary("marker");

      map = new Map(document.getElementById("map"), {
        center: currentPos,
        zoom: 16,
        mapId: "WALKNAV_MAP",
        disableDefaultUI: true,
      });

      currentMarker = new AdvancedMarkerElement({ map, position: currentPos });
      setCoordLabel(currentPos);

      // Try to center to device location once
      try {
        currentPos = await getLocation();
        map.setCenter(currentPos);
        currentMarker.position = currentPos;
        setCoordLabel(currentPos);
        toast("Location updated", true);
      } catch (e) {
        toast(`Location error: ${e.message}`);
      }

      // ---------- Buttons ----------
      document.getElementById("btn-current").addEventListener("click", async () => {
        try {
          const p = await getLocation();
          currentPos = p;
          map.setCenter(p);
          currentMarker.position = p;
          setCoordLabel(p);
          toast("Centered to current position", true);
        } catch (e) {
          toast(`Location error: ${e.message}`);
        }
      });

      document.getElementById("btn-search").addEventListener("click", async () => {
        const q = window.prompt("Search text (e.g., Ramen Tokushima):", "");
        if (!q) return;

        try {
          const res = await cfPlacesSearchText({
            textQuery: q,
            languageCode: "en",
            regionCode: "JP",
            pageSize: 5
          });

          const place = res?.places?.[0];
          if (!place?.location) {
            toast("No results");
            return;
          }

          const pos = {
            lat: place.location.latitude,
            lng: place.location.longitude
          };

          // Update destination marker
          destination = pos;
          if (!destMarker) {
            destMarker = new AdvancedMarkerElement({
              map,
              position: pos
            });
          } else {
            destMarker.position = pos;
          }

          map.panTo(pos);
          toast(place.displayName?.text || "Destination set", true);
        } catch (e) {
          toast(`Search error: ${e.message}`);
        }
      });

      document.getElementById("btn-dest").addEventListener("click", () => {
        if (!destination) {
          toast("Destination not set");
          return;
        }
        map.panTo(destination);
        toast("Destination centered", true);
      });

      document.getElementById("btn-reroute").addEventListener("click", async () => {
        if (!destination) {
          toast("Destination not set");
          return;
        }
        clearRoute();

        try {
          const dir = await cfDirections({
            origin: `${currentPos.lat},${currentPos.lng}`,
            destination: `${destination.lat},${destination.lng}`,
            mode: "walking",
            language: "en",
            region: "JP",
          });

          const points = google.maps.geometry
            ? google.maps.geometry.encoding.decodePath(dir.routes?.[0]?.overview_polyline?.points || "")
            : decodePolyline(dir.routes?.[0]?.overview_polyline?.points || "");

          routePolyline = new google.maps.Polyline({
            path: points,
            map,
            strokeOpacity: 1.0,
          });

          toast("Route updated", true);
        } catch (e) {
          toast(`Directions error: ${e.message}`);
        }
      });

      document.getElementById("btn-stop").addEventListener("click", () => {
        clearRoute();
        toast("Route cleared", true);
      });

      document.getElementById("btn-ops").addEventListener("click", () => {
        toast("Ops tapped");
      });

      // ---------- Fallback polyline decoder (if geometry library absent) ----------
      function decodePolyline(str) {
        let index = 0, lat = 0, lng = 0, coordinates = [];
        while (index < str.length) {
          let b, shift = 0, result = 0;
          do { b = str.charCodeAt(index++) - 63; result |= (b & 0x1f) << shift; shift += 5; } while (b >= 0x20);
          const dlat = (result & 1) ? ~(result >> 1) : (result >> 1);
          lat += dlat;

          shift = 0; result = 0;
          do { b = str.charCodeAt(index++) - 63; result |= (b & 0x1f) << shift; shift += 5; } while (b >= 0x20);
          const dlng = (result & 1) ? ~(result >> 1) : (result >> 1);
          lng += dlng;

          coordinates.push({ lat: lat / 1e5, lng: lng / 1e5 });
        }
        return coordinates;
      }

    } catch (e) {
      console.error(e);
      toast("Map initialization error: " + e.message);
    }
  </script>
</body>
</html>